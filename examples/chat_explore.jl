#=
Difference to chat-client:
This example declares global variables and duck typing.
Examine types in the REPL.
Function containers are explicitly defined with names. Although
anonymous functions may be more commonly used in the web domain,
named functions improve error message readability.
It does not rely on socket ids generated by HttpServer or javascript.
It uses duck typing in order to avoid unneccesary upstream
package requirements.
Argument 'client' (used elsewhere) is renamed to 'thisws' to empasize that WebSockets are initated by
the other end of the connection.
=#
using HttpServer
using HTTP
using WebSockets
global lastreq
global lastws
global lastdata
global lastmsg
global lasthttp
global lastws
global laste
const CLOSEAFTER = Base.Dates.Second(30)
const HTTPPORT = 8080
const PORT_OLDTYPE = 8000
const USERNAMES = Dict{String, WebSocket}()
const CONNECTIONS = Set{WebSocket}()


#=
low level functions
=#
function protectedwrite(ws, msg)
    global laste
    try
        write(ws, msg)
    catch e
        laste = e
        println("Interrupted write! Check global variable laste. Deleting references")
        println(e)
        ws ∈ CONNECTIONS && pop!(CONNECTIONS, ws)
        for (discardname, wsref) in USERNAMES
            if wsref == ws
                pop!(USERNAMES, discardname)
                break
            end
        end
        return false
    end
    true
end

function protectedread(ws)
    global laste
    global lastdata
    data = Vector{UInt8}()
    contflag = true
    try
        data = read(ws)
        lastdata = data
    catch e
        laste = e
        contflag = false
        println("Ouch! Interrupted read. Check global variable laste")
        println(e)
    finally
        return data, contflag
    end
end



function findusername(oldname, msg)
    newname = msg[length("userName:")+1:end]
    if newname == oldname || newname == "" || haskey(USERNAMES, newname)
        return oldname, false
    else
        oldname != "" && pop!(USERNAMES, oldname)
        return newname, true
    end
end


function distributemsg(msgout, not_to_ws)
    foreach(CONNECTIONS) do ws
        if ws != not_to_ws
            protectedwrite(ws, msgout)
        end
    end
    nothing
end

#=
Functions for old type i.e. HttpServer based connections
=#
function wsfunc_oldtype(req, thisws)
    global lastreq
    global lastws
    global lastdata
    global lastmsg
    global laste
    lastreq = req
    lastws = thisws
    push!(CONNECTIONS, thisws)
    contflag = true
    t0 = now()
    data = Vector{UInt8}()
    msg = ""
    username = ""
    changedname = false
    while now()-t0 < CLOSEAFTER && contflag
        data, contflag = protectedread(thisws)
        if contflag
            msg = String(data)
            lastmsg = msg
            println("Received: $msg")
            if startswith(msg, "userName:")
                username, changedname = findusername(username, msg)
            else
                changedname = false
            end
            if changedname
                println("Tell everybody about $username")
                distributemsg(username * " enters chat", thisws)
                USERNAMES[username] = thisws
            else
                if username == ""
                    println("Discarded message, set a unique username!")
                    if !protectedwrite(thisws, "Discarded message, set a unique username!")
                        contflag = false
                    end
                else
                    distributemsg(username * ": " * msg, thisws)
                end
                if contflag
                    contflag = !startswith(msg, "exit")
                    contflag || println("Received exit message. Closing.")
                end
            end
        end
    end
    close(thisws)
    exitusername = username == "" ? "unknown" : username
    println("Closing connection with " * exitusername)
    distributemsg(exitusername * " has left", thisws)
    username != "" &&  pop!(USERNAMES, username)
    thisws ∈ CONNECTIONS && pop!(CONNECTIONS, thisws)
    nothing
end
# Just for easy REPL inspection, we'll declare the handler object explicitly.
# With handler we mean an instance of a structure with at least one function reference.
handler_ws_oldtype = WebSocketHandler(wsfunc_oldtype)
# explicit http server handlers
httpfunc_oldtype(req, res) = readstring(Pkg.dir("WebSockets","examples","chat_explore.html")) |> Response
handler_http_oldtype = HttpHandler(httpfunc_oldtype)
# define both in one server. We could call this a handler, too, since it's just a
# bigger function structure. Or we may call it an object.
server_def_oldtype = Server(handler_http_oldtype, handler_ws_oldtype )

#=
 Now we'll run an external program which starts
 the necessary tasks on Julia.
 We can run this async, which is actually considered
 bad pracice and leads to more bad connections.
 For debugging and building programs, though, it's gold to run this async.
=#
listentask = @async run(server_def_oldtype, PORT_OLDTYPE)

#=

 With listentask, we can for example throw InterrupException at it to close down.
 With recent versions of Julia, we could bind a channel to it as well.
 If we did, errors thrown in the task would have an outlet for its frustracctions.
=#

println("Chat server listening on $PORT_OLDTYPE")



# TODO finish the new way on another simultaneous port.
#task_httpserver = @async run(server, PORT_OLDTYPE)

#    global http
#    global connections
#    if WebSockets.is_upgrade(http.message)
#        WebSockets.upgrade(http) do ws
#            while ws.state == WebSockets.CONNECTED
#                msg = String(read(ws))
#                println(msg) # Write the received message to the REPL
#                protectedwrite(ws,msg)
#            end
#        end
#    end
#end
#function wsh(ws)
#    global connections
#    global lastws
#end
#
#function httph(http)
#    global lasthttp
#    = HttpServerHandler() do req::Request, res::Response
#    onepage = readstring(Pkg.dir("WebSockets","examples","chat-client.html"))
#    Response(onepage)
#end
## Start the echo server
#@async HTTP.listen("127.0.0.1", UInt16(HTTPPORT)) do http
#    if WebSockets.is_upgrade(http.message)
#        WebSockets.upgrade(http) do ws
#            while ws.state == WebSockets.CONNECTED
#                msg = String(read(ws))
#                println(msg) # Write the received message to the REPL
#                protectedwrite(ws,msg)
#            end
#        end
#    end
#end
